# 循环：while 和 for


### 1. 最后一次循环的值

结果是 `1`。

```js
let i = 3;

while (i) {
  alert( i-- );
}
```

每次循环迭代都将 `i` 减  `1`。当检查到 `i = 0` 时，`while(i)` 循环停止。

因此，此循环执行的步骤如下（“循环展开”）：

```js
let i = 3;

alert(i--); // 显示 3，i 减至 2

alert(i--) // 显示 2，i 减至 1

alert(i--) // 显示 1，i 减至 0

// 完成，while(i) 检查循环条件并停止循环
```


### 2. while 循环显示哪些值？

这个题目展现了 i++/++i 两种形式在比较中导致的不同结果。

1. **从 1 到 4：**

```js
let i = 0;
while (++i < 5) alert( i );
```

第一个值是 `i = 1`，因为 `++i` 首先递增 `i` 然后返回新值。因此先比较 `1 < 5` 然后通过 `alert` 显示 `1`。

然后按照 `2, 3, 4…` —— 数值一个接着一个被显示出来。在比较中使用的都是递增后的值，因为 `++` 在变量前。

最终，`i = 4` 时，在 `++i < 5` 的比较中，`i` 值递增至 `5`，所以 `while(5 < 5)` 不符合循环条件，循环停止。所以没有显示 `5`。

2. **从 1 到 5：**

```js
let i = 0;
while (i++ < 5) alert( i );
```

第一个值也是 `i = 1`。后缀形式 `i++` 递增 `i` 然后返回 **旧** 值，因此比较 `i++ < 5` 将使用 `i = 0`（与 `++i < 5` 不同）。

但 `alert` 调用是独立的。这是在递增和比较之后执行的另一条语句。因此它得到了当前的 `i = 1`。

接下来是 `2, 3,4…`

我们在 `i = 4` 时暂停，前缀形式 `++i` 会递增 `i` 并在比较中使用新值 `5`。但我们这里是后缀形式 `i++`。因此，它将 `i` 递增到 `5`，但返回旧值。因此实际比较的是 `while(4 < 5)` —— true，程序继续执行 `alert`。

`i = 5` 是最后一个值，因为下一步比较 `while(5 < 5)` 为 false。


### 3. "for" 循环显示哪些值？

在这两种情况下都是从 `0` 到 `4`。

```js
for (let i = 0; i < 5; ++i) alert( i );

for (let i = 0; i < 5; i++) alert( i );
```

这可以很容易地从 `for` 算法中推导出：

1. 在一切开始之前执行 `i = 0`。
2. 检查 `i < 5` 条件
3. 如果 `true` —— 执行循环体并 `alert(i)`，然后进行 `i++`

递增 `i++` 与检查条件（2）分开。这只是另一种写法。

在这没使用返回的递增值，因此 `i++` 和 `++i`之间没有区别。


### 4. 使用 for 循环输出偶数

```js
for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
```

我们使用 "modulo" 运算符 `%` 来获取余数，并检查奇偶性。


### 5. 用 "while" 替换 "for"

```js
let i = 0;
while (i < 3) {
  alert( `number ${i}!` );
  i++;
}
```


### 6. 重复输入，直到正确为止

```js
let num;

do {
  num = prompt("Enter a number greater than 100?", 0);
} while (num <= 100 && num);
```

两个检查都为真时，继续执行 `do..while` 循环：

1. 检查 `num <= 100` —— 即输入值仍然不大于 `100`。
2. 当 `num` 为 `null` 或空字符串时，`&& num` 的结果为 false。那么 `while` 循环也会停止。

P.S. 如果 `num` 为 `null`，那么 `num <= 100` 为 `true`。因此用户单击取消，如果没有第二次检查，循环就不会停止。两次检查都是必须的。


### 7. 输出素数（prime）

### 答案：

这个题目有很多解法。

我们使用一个嵌套循环：

```js
对于间隔中的每个 i {
  检查在 1~i 之间，是否有 i 的除数
  如果有 => 这个 i 不是素数
  如果没有 => 这个 i 是素数，输出出来
}
```

使用标签的代码：

```js
let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // 对每个自然数 i

  for (let j = 2; j < i; j++) { // 寻找一个除数……
    if (i % j == 0) continue nextPrime; // 不是素数，则继续检查下一个
  }

  alert( i ); // 输出素数
}
```

这段代码有很大的优化空间。例如，我们可以从 `2` 到 `i` 的平方根之间的数中寻找除数。无论怎样，如果我们想要在很大的数字范围内实现高效率，我们需要改变实现方法，依赖高等数学和复杂算法，如[二次筛选法（Quadratic sieve）](https://en.wikipedia.org/wiki/Quadratic_sieve)，[普通数域筛选法（General number field sieve）](https://en.wikipedia.org/wiki/General_number_field_sieve)等。

注：素数也称为质数，对本答案的代码进一步优化，其实就是一道 LeetCode 算法题，感兴趣的可以点击链接查看如何通过 [埃拉托斯特尼筛法筛选素数](https://dingxuewen.com/leetcode-js-leviding/easy/204.count-primes/204.count-primes.html)。
